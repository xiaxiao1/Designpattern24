


定义：
    观察者模式（Observer Pattern） 也叫做发布订阅模式（Publish/subscribe） ,它是一个在项
    目中经常使用的模式， 其定义如下：
    Define a one-to-many dependency between objects so that when one object changes state,all its
    dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系， 使得每
    当一个对象改变状态， 则所有依赖于它的对象都会得到通知并被自动更新。 ）


优点：

    ● 观察者和被观察者之间是抽象耦合
    如此设计， 则不管是增加观察者还是被观察者都非常容易扩展， 而且在Java中都已经实
    现的抽象层级的定义， 在系统扩展方面更是得心应手。
    ● 建立一套触发机制
    根据单一职责原则， 每个类的职责是单一的， 那么怎么把各个单一的职责串联成真实世
    界的复杂的逻辑关系呢？ 比如， 我们去打猎， 打死了一只母鹿， 母鹿有三个幼崽， 因失去了
    母鹿而饿死， 尸体又被两只秃鹰争抢， 因分配不均， 秃鹰开始斗殴， 然后羸弱的秃鹰死掉，
    生存下来的秃鹰， 则因此扩大了地盘……这就是一个触发机制， 形成了一个触发链。 观察者
    模式可以完美地实现这里的链条形式。


缺点：
    观察者模式需要考虑一下开发效率和运行效率问题， 一个被观察者， 多个观察者， 开发
    和调试就会比较复杂， 而且在Java中消息的通知默认是顺序执行， 一个观察者卡壳， 会影响
    整体的执行效率。 在这种情况下， 一般考虑采用异步的方式。
    多级触发时的效率更是让人担忧， 大家在设计时注意考虑。

    那如何异步处理呢？？

适用：
    ● 关联行为场景。 需要注意的是， 关联行为是可拆分的， 而不是“组合”关系。● 事件多级触发场景。
    ● 跨系统的消息交换场景， 如消息队列的处理机制。


注意：
    广播链的问题，它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改
           的， 它是由相邻的两个节点协商的消息结构； 而责任链模式在消息传递过程中基本上保持消
           息不可变， 如果要改变， 也只是在原有的消息上进行修正。

    异步处理问题
    这个EJB是一个非常好的例子， 被观察者发生动作了， 观察者要做出回应， 如果观察者
    比较多， 而且处理时间比较长怎么办？ 那就用异步呗， 异步处理就要考虑线程安全和队列的
    问题， 这个大家有时间看看Message Queue， 就会有更深的了解。

    被观察者尽量自己做主
    这是什么意思呢？ 被观察者的状态改变是否一定要通知观察者呢？ 不一定吧， 在设计的
    时候要灵活考虑， 否则会加重观察者的处理逻辑， 一般是这样做的， 对被观察者的业务逻辑
    doSomething方法实现重载， 如增加一个doSomething(boolean isNotifyObs)方法， 决定是否通知
    观察者， 而不是在消息到达观察者时才判断是否要消费。



    java中以后相关接口提供

