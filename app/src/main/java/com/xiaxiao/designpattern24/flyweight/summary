



定义：
    享元模式（Flyweight Pattern） 是池技术的重要实现方式， 其定义如下： Use sharing to
    support large numbers of fine-grained objects efficiently.（使用共享对象可有效地支持大量的细
    粒度的对象。 ）

    享元模式的定义为我们提出了两个要求： 细粒度的对象和共享对象。 我们知道分配太多
    的对象到应用程序中将有损程序的性能， 同时还容易造成内存溢出， 那怎么避免呢？ 就是享
    元模式提到的共享技术。 我们先来了解一下对象的内部状态和外部状态。



外部状态和内部状态：

    要求细粒度对象， 那么不可避免地使得对象数量多且性质相近， 那我们就将这些对象的
    信息分为两个部分： 内部状态（intrinsic） 与外部状态（extrinsic） 。
    ● 内部状态
    内部状态是对象可共享出来的信息， 存储在享元对象内部并且不会随环境改变而改变，
    如我们例子中的id、 postAddress等， 它们可以作为一个对象的动态附加信息， 不必直接储存
    在具体某个对象中， 属于可以共享的部分。
    ● 外部状态
    外部状态是对象得以依赖的一个标记， 是随环境改变而改变的、 不可以共享的状态， 如
    我们例子中的考试科目+考试地点复合字符串， 它是一批对象的统一标识， 是唯一的一个索
    引值。



优点和缺点：

    享元模式是一个非常简单的模式， 它可以大大减少应用程序创建的对象， 降低程序内存
    的占用， 增强程序的性能， 但它同时也提高了系统复杂性， 需要分离出外部状态和内部状
    态， 而且外部状态具有固化特性， 不应该随内部状态改变而改变， 否则导致系统的逻辑混
    乱。


适用场景：

    ● 系统中存在大量的相似对象。
    ● 细粒度的对象都具备较接近的外部状态， 而且内部状态与环境无关， 也就是说对象没
    有特定身份。
    ● 需要缓冲池的场景。


    尽量使用Java基本类型作为外部状态



注重点：

    虽然可以使用享元模式可以实现对象池， 但是这两者还是有比较大
    的差异， 对象池着重在对象的复用上， 池中的每个对象是可替换的， 从同一个池中获得A对
    象和B对象对客户端来说是完全相同的， 它主要解决复用， 而享元模式在主要解决的对象的
    共享问题， 如何建立多个可共享的细粒度对象则是其关注的重点。

    对象池侧重的是对象的复用，
    享元模式注重的是如何建立多个可共享的细粒度对象


















