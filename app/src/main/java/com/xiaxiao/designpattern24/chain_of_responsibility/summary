



Avoid coupling the sender of a request to its receiver by giving more than one object a chance to
handle the request.Chain the receiving objects and pass the request along the chain until an object
handles it.（使多个对象都有机会处理请求， 从而避免了请求的发送者和接受者之间的耦合关
系。 将这些对象连成一条链， 并沿着这条链传递该请求， 直到有对象处理它为止。 ）


    抽象的处理者实现三个职责： 一是定义一个请求的处理方法handleMessage， 唯一对外开
    放的方法； 二是定义一个链的编排方法setNext， 设置下一个处理者； 三是定义了具体的请求
    者必须实现的两个方法： 定义自己能够处理的级别getHandlerLevel和具体的处理任务echo。

    请注意handlerMessage方法前的final关键字，

优点：
    责任链模式非常显著的优点是将请求和处理分开。 请求者可以不用知道是谁处理的， 处
    理者可以不用知道请求的全貌（例如在J2EE项目开发中， 可以剥离出无状态Bean由责任链处
    理） ， 两者解耦， 提高系统的灵活性。

缺点：
    责任链有两个非常显著的缺点： 一是性能问题， 每个请求都是从链头遍历到链尾， 特别
    是在链比较长的时候， 性能是一个非常大的问题。 二是调试不很方便， 特别是链条比较长，
    环节比较多的时候， 由于采用了类似递归的方式， 调试的时候逻辑可能比较复杂。

使用：
    各个实现类只要关注的自己业务逻辑就成了， 至于说什么事
    要自己处理， 那就让父类去决定好了， 也就是说父类实现了请求传递的功能， 子类实现请求
    的处理， 符合单一职责原则， 各个实现类只完成一个动作或逻辑， 也就是只有一个原因引起
    类的改变， 我建议大家在使用的时候用这种方法， 好处是非常明显的了， 子类的实现非常简
    单， 责任链的建立也是非常灵活的。
    责任链模式屏蔽了请求的处理过程， 你发起一个请求到底是谁处理的， 这个你不用关
    心， 只要你把请求抛给责任链的第一个处理者， 最终会返回一个处理结果（当然也可以不做
    任何处理） ， 作为请求者可以不用知道到底是需要谁来处理的， 这是责任链模式的核心， 同
    时责任链模式也可以作为一种补救模式来使用。


和观察者模式的区别：
                还有一个问题需要和大家说明一下，观察者模式也可以实现请求的传递，比如一个事件发生了，通知
                了观察者，同时观察者又作为一个被观察者，通知了另外一个观察者，这也形成了一个事件广播链，这和
                我们今天讲的责任链是有区别的：
                受众数量不同。观察者广播链式可以 1：N 的方式广播，而责任链则要求是的 1:1 的传递，必然有一个
                且只有一个类完成请求的处理；
                请求内容不同。观察者广播链中的信息可以在传播中改变，但是责任链中的请求是不可改变的；
                处理逻辑不通。观察者广播链主要用于触发联动动作，而责任链则是对一个类型的请求按照既定的规
                则进行处理。