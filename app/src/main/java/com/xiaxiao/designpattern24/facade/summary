
也叫做外观模式

个人感觉就是将一套繁杂的事务封装到一个方法里，配备参数，对外提供一个直接的调用既可，唯一注意的是：
所有的事务时在一个类中，而对外调用则是由另外一个类封装提供

要求一个子系统的外部与其内部的通信必须通
过一个统一的对象进行。 门面模式提供一个高层次的接口， 使得子系统更易于使用


这是一个很好的封装方法，一个子系统比较复杂的实话，比如算法或者业务比较
复杂，就可以封装出一个或多个门面出来，项目的结构简单，而且扩展性非常好。还有，在一个较大项目
中的时候，为了避免人员带来的风险，也可以使用这个模式，技术水平比较差的成员，尽量安排独立的模
块（Sub System），然后把他写的程序封装到一个门面里，尽量让其他项目成员不用看到这些烂人的代码，
看也看不懂，我也遇到过一个“高人”写的代码，private 方法、构造函数、常量基本都不用，你要一个
public 方法，好，一个类里就一个 public 方法，所有代码都在里面，然后你就看吧，一大坨的程序，看着
能把人逼疯，使用门面模式后，对门面进行单元测试，约束项目成员的代码质量，对项目整体质量的提升
也是一个比较好的帮助。



缺点：：

门面模式最大的缺点就是不符合开闭原则， 对修改关闭， 对扩展开放， 看看我们那个门
面对象吧， 它可是重中之重， 一旦在系统投产后发现有一个小错误， 你怎么解决？ 完全遵从
开闭原则， 根本没办法解决。 继承？ 覆写？ 都顶不上用， 唯一能做的一件事就是修改门面角
色的代码， 这个风险相当大， 这就需要大家在设计的时候慎之又慎， 多思考几遍才会有好收
获




适用场景：

为一个复杂的模块或子系统提供一个供外界访问的接口
 子系统相对独立——外界对子系统的访问只要黑箱操作即可


一个子系统可以有多个门面：


门面已经庞大到不能忍受的程度，可以按功能拆分

当对子系统的访问有不同的权限限制的时候，可以分别创建不同的门面以供使用


门面不参与子系统内的业务逻辑：

public class Facade {
//被委托的对象
private ClassA a = new ClassA();
private ClassB b = new ClassB();
private ClassC c = new ClassC();
//提供给外部访问的方法
public void methodA(){
this.a.doSomethingA();
} p
ublic void methodB(){
this.b.doSomethingB();
} p
ublic void methodC(){
this.a.doSomethingA();
this.c.doSomethingC();
}
}
还是非常简单， 只是在methodC方法中增加了doSomethingA()方法的调用， 可以这样做
吗？ 我相信大部分读者都说可以这样做， 而且已经在实际系统开发中这样使用了， 我今天告
诉各位， 这样设计是非常不靠谱的， 为什么呢？ 因为你已经让门面对象参与了业务逻辑，

门面对象只是提供一个访问子系统的一个路径而已， 它不应该也不能参与具体的业务逻辑， 否
则就会产生一个倒依赖的问题： 子系统必须依赖门面才能被访问， 这是设计上一个严重错
误， 不仅违反了单一职责原则， 同时也破坏了系统的封装性















