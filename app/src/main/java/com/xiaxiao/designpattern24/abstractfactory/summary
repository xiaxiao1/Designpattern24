

为创建一组相关或相互依赖的对象提供一个接口， 而且无须指定它们
的具体类。

抽象工厂模式：：

                                    职责分明


优点：

封装性， 每个产品的实现类不是高层模块要关心的， 它要关心的是什么？ 是接口， 是
抽象， 它不关心对象是如何创建出来， 这由谁负责呢？ 工厂类， 只要知道工厂类是谁， 我就
能创建出一个需要的对象， 省时省力， 优秀设计就应该如此。

产品族内的约束为非公开状态。 例如生产男女比例的问题上， 猜想女娲娘娘肯定有自
己的打算， 不能让女盛男衰， 否则女性的优点不就体现不出来了吗？ 那在抽象工厂模式， 就
应该有这样的一个约束： 每生产1个女性， 就同时生产出1.2个男性， 这样的生产过程对调用
工厂类的高层模块来说是透明的， 它不需要知道这个约束， 我就是要一个黄色女性产品就可
以了， 具体的产品族内的约束是在工厂内实现的。



缺点：

抽象工厂模式的最大缺点就是产品族扩展非常困难，

为什么这么说呢？ 我们以通用代码
为例， 如果要增加一个产品C， 也就是说产品家族由原来的2个增加到3个， 看看我们的程序
有多大改动吧！ 抽象类AbstractCreator要增加一个方法createProductC()， 然后两个实现类都要
修改， 想想看， 这严重违反了开闭原则， 而且我们一直说明抽象类和接口是一个契约。 改变
契约， 所有与契约有关系的代码都要修改， 那么这段代码叫什么？ 叫“有毒代码”， ——只要
与这段代码有关系， 就可能产生侵害的危险！

所以抽象工厂模式适合应用于契约比较稳定，不会变化的场景



工厂模式符合 OCP 原则，也就是开闭原则，怎么说呢，比如就性别的问题，
这个世界上还存在双性人，是男也是女的人，那这个就是要在我们的产品族中增加一类产品，同时再增加
一个工厂就可以解决这个问题，不需要我再来实现了吧，很简单的大家自己画下类图，然后实现下。
那还有没有其他好处呢？抽象工厂模式，还有一个非常大的有点，高内聚，低耦合，在一个较大的项
目组，产品是由一批人定义开发的，但是提供其他成员访问的时候，只有工厂方法和产品的接口，也就是
说只需要提供 Product Interface 和 Concrete Factory 就可以产生自己需要的对象和方法，Java 的高内聚
低耦合的特性表现的一览无遗