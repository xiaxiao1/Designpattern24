



需要备份的时
候就创建一个备份， 然后丢给备忘录管理者进行管理， 要取的时候再从管理者手中拿到这个
备份。 这个备份者就类似于一个备份的仓库管理员， 创建一个丢进去， 需要的时候再拿出
来。 这就是备忘录模式。

定义：
    Without violating encapsulation,capture and externalize an object's internal state so that the
    object can be restored to this state later.（在不破坏封装性的前提下， 捕获一个对象的内部状
    态， 并在该对象之外保存这个状态。 这样以后就可将该对象恢复到原先保存的状态。 ）
    通俗地说， 备忘录模式就是一个对象的备份模式， 提供了一种程序数据的备份方法，


角色：
    ● Originator发起人角色
    记录当前时刻的内部状态， 负责定义哪些属于备份范围的状态， 负责创建和恢复备忘录
    数据。
    ● Memento备忘录角色
    负责存储Originator发起人对象的内部状态， 在需要的时候提供发起人需要的内部状态。
    ● Caretaker备忘录管理员角色对备忘录进行管理、 保存和提供备忘录。


使用场景：
    ● 需要保存和恢复数据的相关状态场景。
    ● 提供一个可回滚（rollback） 的操作； 比如Word中的CTRL+Z组合键， IE浏览器中的后
    退按钮， 文件管理器上的backspace键等。
    ● 需要监控的副本场景中。 例如要监控一个对象的属性， 但是监控又不应该作为系统的
    主业务来调用， 它只是边缘应用， 即使出现监控不准、 错误报警也影响不大， 因此一般的做
    法是备份一个主线程中的对象， 然后由分析程序来分析。
    ● 数据库连接的事务管理就是用的备忘录模式， 想想看， 如果你要实现一个JDBC驱
    动， 你怎么来实现事务？ 还不是用备忘录模式嘛！


注意：
    ● 备忘录的生命期
    备忘录创建出来就要在“最近”的代码中使用， 要主动管理它的生命周期， 建立就要使
    用， 不使用就要立刻删除其引用， 等待垃圾回收器对它的回收处理。
    ● 备忘录的性能
    不要在频繁建立备份的场景中使用备忘录模式（比如一个for循环中） ， 原因有二： 一是控制不了备忘录建立的对象数量； 二是大对象的建立是要消耗资源的， 系统的性能需要考
    虑。

   内存溢出问题， 该备份一旦产生就装入内存， 没有任何销毁的意向， 这是非常危
   险的。 因此， 在系统设计时， 要严格限定备忘录的创建， 建议增加Map的上限， 否则系统很
   容易产生内存溢出情况。


数据安全：
    在系统管理上， 一个备份的数据是完全、 绝对不能修改的， 它保证数据的洁净， 避免数
    据污染而使备份失去意义。 在我们的设计领域中， 也存在着同样的问题， 备份是不能被篡改
    的， 也就是说需要缩小备份出的备忘录的阅读权限， 保证只能是发起人可读就成了， 那怎么
    才能做到这一点呢？ 使用内置类，

    这也是比较简单的， 建立一个空接口IMemento——什么方法属性都没有的接口， 然后在
    发起人Originator类中建立一个内置类（也叫做类中类） Memento实现IMemento接口， 同时也
    实现自己的业务逻辑，

    内置类Memento全部是private的访问权限， 也就是说除了发起人外， 别人休想访问到，
    那如果要产生关联关系又应如何处理呢？ 通过接口！ 别忘记了我们还有一个空接口是公共的
    访问权限，


双接口设计：
    双接口设计， 我们的一个类可以实现多个接口，
    在系统设计时， 如果考虑对象的安全问题， 则可以提供两个接口， 一个是业务的正常接口，
    实现必要的业务逻辑， 叫做宽接口； 另外一个接口是一个空接口， 什么方法都没有， 其目的
    是提供给子系统外的模块访问， 比如容器对象， 这个叫做窄接口， 由于窄接口中没有提供任何操纵数据的方法， 因此相对来说比较安全。